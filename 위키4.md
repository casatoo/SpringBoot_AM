## 2022.09.23
- 롬복 설치와 적용
- 스프링 부트 프로젝트 생성
    - 복습하면서 다시 만들어보자
    - Spring Starter Project
    - Maven Project, War
    - Lombok, Spring Boot DevTools, Spring Web4

- Controller 만들기
    - 컨트롤러 안에서 페이지 생성

    ```java
        @Controller
        public class UsrHomeController {
            @RequestMapping("/usr/home/main")
	        @ResponseBody
	        public String showMain() {
		    return "안녕하세요";
	        }
        }
    ```
    - @Controller 를 해주면 해당 클래스는 컨트롤러의 역할을 한다.
    - @RequestMapping("/usr/home/main") 로 경로를 지정

     ```java
        @Controller
        public class UsrHomeController {
	    int count;
	
	    public UsrHomeController(){
		count = 0;
	    }
	
        @RequestMapping("/usr/home/main")
        @ResponseBody
        public String showMain() {
            return "안녕하세요";
        }
        @RequestMapping("/usr/home/main2")
        @ResponseBody
        public String showMain2() {
            return "반갑습니다.";
        } 
        @RequestMapping("/usr/home/main3")
        @ResponseBody
        public String showMain3() {
            return "잘가요";
        }
        @RequestMapping("/usr/home/getCount")
        @ResponseBody
        public int showMain4() {
            return count++;
        }
        @RequestMapping("/usr/home/doSetCount")
        @ResponseBody
        public String doSetCount(int Count) {
            this.count = Count;
            return "카운트 값이 "+ count+"으로 초기화 됨";
            }
        }
    ```
    - 일반 자바 클래스 처럼 변수를 선언하고 페이지를 선언한 메서드 안에서 활용이 가능하다.
    - 메서드 인자로 받는 경우 페이지 주소에서 값을 받아올 수 있다.
    - /usr/home/doSetCount?Count=10 이렇게 하면 doSetCount 메서드에 int Count 값을 10으로 받아온다.
    - 리스트나 맵으로 값을 리턴할 수 도 있는데
    ```java
    @RequestMapping("/usr/home/getMap")
	@ResponseBody
	public Map getMap() {
		Map<String,Object> map = new HashMap<>();
		map.put("철수나이",22);
		map.put("영희나이",22);
		return map;
	}
	@RequestMapping("/usr/home/getList")
	@ResponseBody
	public List<String> getList() {
		List<String> list = new ArrayList<>();
		list.add("철수나이");
		list.add("영희나이");
		return list;
	}
    ```
    - 이렇게할경우 Map은{"철수나이":22,"영희나이":22} List는 ["철수나이","영희나이"] 이렇게 출력됨
    - @getter
    - @Data
    - @AllArgsConstructor 생성자를 만들어주는 어노테이션
    - @NOArgsConstructor 생성자를 만드는데 인자값은 없음
    - 객체를 만들어서 리스트에 담는 경우 Articles
    ```java
    @RequestMapping("usr/home/getArticle")
	@ResponseBody
	public Article getArticle() {
		Article article = new Article(1, "제목1");
		Article article2 = new Article();

		return article;
	}

	@RequestMapping("usr/home/getArticles")
	@ResponseBody
	public List<Article> getArticles() {
		Article article1 = new Article(1, "제목1");
		Article article2 = new Article(2, "제목2");

		List<Article> articles = new ArrayList<>();
		articles.add(article1);
		articles.add(article2);

		return articles;
	}
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    class Article {
	private int id;
	private String title;

    }
    ```
    - articles 는 [{"1","제목1"},{"2","제목2"}]
    - 값을 파라미터로 받아올때 & 로 구분하는거 잊지말자

## 2022.09.26

- 테스트 데이터 추가
- 리스트 기능 구현
- 삭제기능 구현 doDelete
    - id 값을 가져와서 동일 id 값의 글을 찾아야 함
        - article 가져오는 서비스 메서드 구현
        ```java
        private Article getArticle(int id){
            for(Article article : articles){
                if(article.getId()==id){
                    return article;
                }
            }
            return null;
        }
        ```
    - 배열에서 불러온 해당 article 삭제
    ```java
    private void deleteArticle(int id) {
    	Article article = getArticle(id);
    	
    	articles.remove(article);
    }
    @RequestMapping("/usr/article/doDelete")
	@ResponseBody
	public String doDelete(int id) {
		Article article = getArticle(id);
		if(article == null) {
			return id+"번 게시물은 존재하지 않습니다.";
		}
		deleteArticle(id);
		return id+"번 게시물을 삭제했습니다.";
	}
    ```
- 글 수정기능 구현
    - domodify
    - delete 참고
    - 수정할 title, body 는 파라미터로 받아옴
    - 글번호를 조회해서 가져오고 set 함수로 값 변경
    ```java
        Article article = getArticle(id);
    	
		article.setTitle(title);
		article.setBody(body);
    ```

- 글 상세보기
    - String 으로 묶어서 출력 했다..
    ```java
    @RequestMapping("/usr/article/detail")
	@ResponseBody
	public String showDetail(int id) {
		Article article = getArticle(id);
		if(article == null) {
			return id+"번 게시물은 존재하지 않습니다.";
		}
		String articleDetail ="";
		articleDetail += (article.getId()+"번 게시물 상세보기");
		articleDetail += ("제목: "+article.getTitle()+"\n");
		articleDetail += ("내용: "+article.getBody());
		
		return articleDetail;
	}
    ```
    - 이렇게 했었는데 object 객체로 변경하면 그냥 가능했다

    ``java
    @RequestMapping("/usr/article/detail")
	@ResponseBody
	public Object showDetail(int id) {
		Article article = getArticle(id);
		if(article == null) {
			return id+"번 게시물은 존재하지 않습니다.";
		}
		return article;
	}
    ```
- MVC
    - 모델, 뷰, 컨트롤러
    - 모델(model)
        - 로직, 영혼
    - 뷰(view)
        - 보이는부분 육체
    - 컨트롤러(controller)
        - 정신 모델과 뷰를 잇는다.
- Spring MVC
    - 모델, 뷰, 컨트롤러
    - 모델(model)
        - 서비스
        - 리포지터리
        - DB
    - 뷰(view)
        - JSP
        - JS
        - CSS
        - HTML
    - 컨트롤러(controller)
        - 컨트롤러
- 서비스 도입
    - @Service 생성
    - @Autowired 로 서비스와 컨트롤러를 연결시켜준다.
    ```java
    @Controller
    public class UsrArticleController {
	
	@Autowired
	private ArticleService articleservice;
    ```
    - 엑션 메소드가 아닌 일반 메소드들은 서비스로 넘겨준다.
    - 컨트롤러에서 일반 메소드의 작동은 articleservice.(메소드명) 으로 사용한다.
    - private 로 접근이 불가능한것은 public 으로 변경

## 2022.09.27
- 구조를 다시 살펴보자.
    - com.KMS.exam.demo 로 패키지가 생성 되었고
    - 그 안에 컨트롤러, 서비스, vo를 만들어주고
    - 컨트롤러에는 @Controller 를 써주고
    - 서비스에는 @Service 를 써준다.
    - vo에는 article 객체를 만들고 @Data 를 해서 안에 있는 인자를 사용할 수있게 했다. (getid, getTitle 등)
    - spring을 실행시키면 컨트롤러 맵핑된 주소의 메서드가 실행되고 메서드에서는 service가 처리해주는 것을 받아서 보여준다.

- 리포지터리 도입 (데이터 저장의 역할)
    - 서비스에서 가지고 있는 데이터를 여기다 넣고 여기서 서비스가 가져다 쓰는걸로? 해도 되는건가..
    - 구글링 해보자
    ```java
    @Component
    public class ArticleRepository {
    }
    ```
    ```java
    @Service
    public class ArticleService{
	
	@Autowired
	private ArticleRepository articleRepository;
	
	public ArticleService(ArticleRepository articleRepository) {
		this.articleRepository = articleRepository;
		articleRepository.makeTestData();
	}
    ```
    - 서비스 생성자에 리퍼지토리를 인자로 받아야 함

- 처음부터 다시 만들어보기
    - 스프링 부트 프로젝트 생성
    - 복습하면서 다시 만들어보자
    - Spring Starter Project
    - Maven Project, War
    - Lombok, Spring Boot DevTools, Spring Web
    - src/main/resources / application.properties 확장자명 변경
    - application.yml
    - article 관련 기능 생성
        - article vo 생성
            - @Data
            - @NoArgsConstructor (인자값 없는 생성자)
            - @AllArgsConstructor (인자갑 전부 받는 생성자)
        - article controller
            - controller 에서 맵핑
            - doAdd
            - getArticle
            - getArticles
            - doDelete
            - doModify
        - article service
        - article repository

- 데이터 베이스 연결
    - 의존성 추가(dependency)
    - maven 홈페이지 
    - mybatis spring boot starter
    - 2.2.2 들어가서 클릭하면 복사됨
    - pom.xml 에 dependency 에 붙여넣기
    - or 프로젝트 우클릭 - spring Add starters 에서
    - mybatis , mysql 커넥터 추가
    - application.yml 수정
        ```xml
        server:
            port: 8081
        spring:
            datasource:
            driver-class-name: jdbc:mysql://1.234.44.77:3306/SB_AM?useUnicode=true&characterEncoding=utf8&autoReconnect=true&serverTimezone=Asia/Seoul&useOldAliasMetadataBehavior=true&zeroDateTimeNehavior=convertToNull
        username: user1
        password: mkop9074!@
        mybatis:
            type-aliases-package: com.KMS.exam.demo.vo
        ```
    - repository 를 @Mapper 으로 변경
    - class 를 interface로 변경
    - 메소드 형식을 interface에 맞게 수정한다.
    - 퀴리문 실행은 어노테이션을 이용한다.
    ```java 
    @Select("SELECT * FROM article WHERE id = #{id}")
    public Article getArticle(int id);
    ```
    - 원래는 @Param 파라미터라고 알려줘야 됬었다고 한다.
    ```java
    public Article getArticle(@Param("id") int id);
    ```
    - LAST_INSERT_ID() 
    - 글 생성시에 리턴타입이 맞지않아 오류페이지가 출력되는 상황
        - LAST_INSERT_ID() 로 마지막 삽입, 수정된 글 번호 추출해서
        - select 문으로 불러와서 리턴
        - write 리턴타입 int 로 해서 리턴하고 service에서 getArticle 로 불러와서 리턴?
        - insert는 더이상 결과값을 가져오지 않으므로 void로 해줘야 한다.

    - doModify 에서 글 수정시에 예전값을 가져오는것도 수정이 필요하다.


## 2022.09.28

- articlerepository.xml 작성
    - 리포지토리와 xml 의 연동
        - namespase로 리포지토리를 연동하고
        - 쿼리문을 각각 저장한다.
        - return 은 resultType 으로 vo 안에 있는 객체 이름을 적어준다.
        - int 타입은 생략 가능
        - application.yml 에서 마이바티스로 설정한 vo 주소가 여기에서 주소를 줄여주는 역할을 해준다.
        - 원래 리포지토리에서 작성된 쿼리는 지운다.

        ```xml
        <?xml version="1.0" encoding="UTF-8" ?>
        <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

        <mapper namespace="com.KMS.exam.demo.repository">
        <insert id="writeArticle">
        INSERT INTO article 
        SET regDate = NOW(), 
        updateDate = NOW(), 
        title = #{title},
        `body` = #{body}
        </insert>
        <select id="getArticle" resultType="Article">
        SELECT * FROM article 
        WHERE id = #{id}
        </select>
        <select id="getArticles" resultType="Article">
        SELECT * FROM article 
        ORDER BY id DESC
        </select>
        <delete id="deleteArticle">
        DELETE FROM article 
        WHERE id = #{id}
        </delete>
        <update id="modifyArticle">
        UPDATE article SET 
        title = #{title}, 
        `body` = #{body}, 
        updateDate = NOW() 
        WHERE id = #{id}
        </update>
        <select id="getLastInsertId">
        SELECT LAST_INSERT_ID()
        </select>
        </mapper>
        ```

    - 입력된 정보만 수정될 수 있도록 작업
        - modify에서 제목이나 내용이 입력되지않을 경우 입력값이 전달되지 않아 오류가 발생하는 문제를 해결
        - mybatis 공식 사이트에서 검색
        - 조건식에 따른 쿼리 실행으로 값을 SET 할 수 있다.
        ```xml
        <update id="modifyArticle">
		UPDATE article
		<set>
			<if test="title != null and title !=''">title = #{title},</if>
			<if test="body != null and body !=''">`body` = #{body},</if>
			updateDate = NOW()
		</set>
		WHERE id = #{id}
	    </update>
        ```

    - tailwindcss
        - css 라이브러리
        - (치트시트)[https://nerdcave.com/tailwind-cheat-sheet]
    
    - memberController 만들기
        - usr/member/dojoin
            - loginId
            - loginPw
            - name
            - nickName
            - cellphoneNum
            - email
        1. member 테이블 생성 (comment에 대해서 알아볼것.)
        ```sql
        CREATE TABLE `member`(
        id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY,
        regDate DATETIME NOT NULL,
        updateDate DATETIME NOT NULL,
        loginId VARCHAR(20) NOT NULL,
        loginPw VARCHAR(20) NOT NULL,
        `authLevel` SMALLINT(2) UNSIGNED DEFAULT 3 COMMENT '권한 레벨 (3=일반,7=관리자)',
        `name` VARCHAR(20) NOT NULL,
        nickname VARCHAR(20) NOT NULL,
        cellphoneNum VARCHAR(20) NOT NULL,
        email VARCHAR(50) NOT NULL,
        delStatus TINYINT(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '탈퇴여부 (0=탈퇴 전, 1= 탈퇴 후)',
        delDate DATETIME COMMENT '탈퇴날짜'
        );
        ```
        2. 관리자 계정 생성
        3. memberRepository.xml 생성, 쿼리 작성
        4. 글생성과 비슷한 방법으로 가입하고 마지막 insert된 정보를 받아서 가입인사 출력

## 2022.09.29

- 남아있는 작업
    - 회원 가입 시 아이디 중복 체크
        - 중복된 아이디의 경우 이미가입된 아이디 메세지 출력
        - 입력된 loginId로 데이터베이스 확인
        - count(*)
        - 1 이면 중복 0 이면 통과
        - xml파일에서 resultType 을 지정하지 않으면 오류가 발생하니 주의
    - 글 작성자 컬럼 추가
        - 데이터베이스 컬럼 추가
        - 테스트 데이터에 작성자 id 추가
        - vo article에 작성자 추가
    - 로그인 기능 추가
        - 로그인 할때 id 체크
            - 회원가입때 사용한거 다시 활용
        - 비밀번호 체크
            - id 가 확인된 상태이기 때문에 loginId 를 통해  PW 를 가져오는 쿼리를 작성
        
    - 로그아웃 기능 추가
    - 글 수정, 삭제 권한

    - 회원가입시에 이름과+이메일이 일치하는 경우 중복
        - 이미 가입된 회원입니다 를 표시하자
        